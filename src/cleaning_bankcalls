from pathlib import Path
import zipfile
import pandas as pd
import re

BASE_DIR = Path(__file__).resolve().parent.parent
DATA_DIR = BASE_DIR / "_data"
DATA_DIR.mkdir(exist_ok=True)

zip_path = DATA_DIR / "FFIEC CDR Call Bulk All Schedules 03312022.zip"

SCHEDULES = ["RC", "RCB", "RCCI", "RCCII", "RCE", "RCO"]


def load_schedule(zip_path: Path, schedule_name: str) -> pd.DataFrame:
    """
    Load a schedule from the FFIEC CDR zip file by schedule name,
    automatically handling multi-part files (e.g. '1 of 2', '2 of 2').

    Args:
        zip_path: Path to the zip file.
        schedule_name: The schedule identifier, e.g. 'RC', 'RCB', 'RCO'.

    Returns:
        A single concatenated DataFrame for that schedule.
    """
    # Pattern: "FFIEC CDR Call Schedule {NAME}" followed by optional (N of M) and the date
    # This deliberately ignores the date portion to stay generalizable
    pattern = re.compile(
        rf"FFIEC CDR Call Schedule {re.escape(schedule_name)}\b",
        re.IGNORECASE
    )

    with zipfile.ZipFile(zip_path, "r") as zf:
        all_names = zf.namelist()

        matched = sorted([
            name for name in all_names
            if pattern.search(Path(name).stem)  # match against filename without extension
        ])

        if not matched:
            raise FileNotFoundError(
                f"No files found for schedule '{schedule_name}' in {zip_path.name}"
            )

        print(f"  [{schedule_name}] Found {len(matched)} file(s): {[Path(m).name for m in matched]}")

        parts = []
        for name in matched:
            with zf.open(name) as f:
                df = pd.read_csv(f, encoding="utf-8", low_memory=False, sep="\t", skiprows=[1])
                parts.append(df)

    return pd.concat(parts, ignore_index=True) if len(parts) > 1 else parts[0]


def load_all_schedules(zip_path: Path, schedules: list[str]) -> dict[str, pd.DataFrame]:
    """
    Load multiple schedules from the zip file into a dict of DataFrames.

    Args:
        zip_path: Path to the zip file.
        schedules: List of schedule names to load.

    Returns:
        Dict mapping schedule name -> DataFrame.
    """
    results = {}
    for schedule in schedules:
        print(f"Loading schedule {schedule}...")
        results[schedule] = load_schedule(zip_path, schedule)
        print(f"  -> Shape: {results[schedule].shape}\n")
    return results


# --- Run ---
dfs = load_all_schedules(zip_path, SCHEDULES)
dfs['RC']


# Access individual schedules like:
# dfs["RC"], dfs["RCB"], dfs["RCO"] etc.